#!/usr/local/bin/perl
# ======================================================================
#+
$usage = "\n
NAME
        lineplot.pl

PURPOSE
        Plot two or three column plain text files as connected points
        with error bars.

USAGE
        lineplot.pl [flags] [options] $project.txt $other.txt ...

FLAGS
        -u        Print this message
        -l        Connect points with a line
        -p        Plot data points
        -e        Plot error bars
        -q        Plot quietly (no X display)

INPUTS
        $project.txt        3 column text file (x, y, error)

OPTIONAL INPUTS
        -v        i         Verbosity (0, 1 or 2)
        -xmin     f         Window xmin
        -xmax     f         xmax
        -ymin     f         ymin
        -ymax     f         ymax
        -color    i         PGPLOT color index
        -lw       i         PGPLOT line width
        -ls       i         PGPLOT line style
        -ch       f         PGPLOT character height
        -o        $project  Postscript output file

        $other.txt          Additional text file

OUTPUTS
        $project.ps         Postscript plot

COMMENTS
  - PGPLOT module requires /usr/local/bin/perl at KIPAC

EXAMPLES

BUGS
  - Colouring is hard-coded
  - No legends are added to graph

REVISION HISTORY:
  2005-08-02  Started Marshall and Cevallos (KIPAC)

\n";

#-
# ======================================================================

use PGPLOT;

# Parse options:

use Getopt::Long;
GetOptions("o=s", \$plotfile,
           "v=i", \$verb,
           "xmin=f", \$xmin,
           "xmax=f", \$xmax,
           "ymin=f", \$ymin,
           "ymax=f", \$ymax,
           "color=i", \$color,
           "ls=i", \$linestyle,
           "ch=f", \$ch,
           "lw=i", \$lw,
           "e", \$errors,
           "p", \$points,
           "l", \$line,
           "q", \$quiet,
           "xlabel=s", \$xlabel,
           "ylabel=s", \$ylabel,
           "title=s", \$title,
           "u", \$help
           );

(defined($help)) and die "$usage\n";

(defined($verb)) or ($verb = 0);

# If -e is selected, term is the relative length of error bar terminals
(defined($errors)) and ($points = 1);
$term = 0.3;

# General character height:
(defined($ch)) or $ch = 1.5;

# General line width:
$lw0 = 2;

# Plot line width:
(defined($lw)) or $lw = $lw0;

# General line style:
$ls0 = 1;
(defined($linestyle)) and $ls = $linestyle;

# General line colour:
(defined($color)) and $ci = $color;
(defined($color)) or $ci = 1;

# Plot labelling:
(defined($xlabel)) or $xlabel = " ";
(defined($ylabel)) or $ylabel = " ";
(defined($title)) or $title = " ";


# Grab files from command line, and set up other file names:
$k = 0;
while (defined($infile = shift)){
  open (IN, $infile) or die "$infile: $!";
  close (IN);
  $file[$k] = $infile;
  $k++;
}
$nfiles = $k;

(defined($plotfile)) or ($sensible = 1);

(defined($sensible) and $nfiles > 1) and die "Must specify postscript filename with more than one file.";

if (defined($sensible)) {
   $plotfile = $file[0];
   $plotfile =~ s/(.*)\..*/$1/;
   $plotfile = $plotfile.".ps";
}

# ----------------------------------------------------------------------

# Plot twice, once to screen and once to file:

for($k=0; $k<2; $k++){

  if($k == 0){
    $device = "/xs";
    defined($quiet) and $device = "/null";
  }
  else{
     $device = "$plotfile/vcps";
  }
  ($verb == 2) and print "Device set to $device\n";

  pgbeg(0,$device,1,1);
  pgpap(0.0,0.707);
#   pgsvp(0.15,0.9,0.15,0.9);
  pgsch($ch);
  pgslw($lw0);

# Open up file, read in 2 or 3 columns, and add to plot:

  for($j=0; $j<$nfiles; $j++){

    (($verb > 0) and $k == 0) and print "Reading data from $file[$j]\n";
    open (IN, $file[$j]);

    (($verb > 1) and $k == 0) and print "Contents are: \n";
    $i = 0;
    while (<IN>){

      next if (/^\#/ or /^$/);
      chomp;
      @cols = split;

         $x[$i] = $cols[0];
         $y[$i] = $cols[1];
         $stdev[$i] = $cols[2];

         (($verb > 1) and $k == 0) and print "$x[$i] $y[$i] $stdev[$i] \n";

         if(defined($errors)){
           $ylower[$i] = $y[$i] - $stdev[$i];
           $yupper[$i] = $y[$i] + $stdev[$i];
         }

      $i++;
     }
     $nlines = $i;
     (($verb > 0) and $k == 0) and print "$nlines lines read\n";

     close (IN);

     if($j == 0 and $k ==0){
        @temp = minmax(@x);
        (defined($xmin)) or $xmin = $temp[0];
        (defined($xmax)) or $xmax = $temp[1];
        @temp = minmax(@y);
        (defined($ymin)) or $ymin = $temp[0];
        (defined($ymax)) or $ymax = $temp[1];
        ($verb>0) and print "Window limits set to $xmin $xmax $ymin $ymax\n";
     }
     if($j == 0){
       pgsci(1);
#        pgwindow($xmin,$xmax,$ymin,$ymax);
#        pgbox("BCNST",0.0,0,"BCNST",0.0,0);
       pgenv($xmin,$xmax,$ymin,$ymax,0,1);
     }

     # white = 1, red = 2, green =3, blue =4 etc etc

     (defined($color)) or $ci = $j + 1;
     ($verb > 0) and print "Dataset $j: colour index set to $ci\n";
     pgsci($ci);

     # solid = 1, dashed = 2, dot-dashed =3, dotted =4

     if ( ! defined($linestyle)){
       $ls = 1;
       ($j eq 0) and $ls = 1;
       ($j eq 1) and $ls = 4;
       ($j eq 2) and $ls = 2;
       ($j eq 3) and $ls = 3;
    }
     ($verb > 0) and print "Dataset $j: line style set to $ls\n";
     pgsls($ls);

     pgslw($lw);
     defined($line) and pgline($nlines, \@x, \@y);
     
     pgslw($lw0);
     pgsls($ls0);

     defined($points) and pgpt($nlines,\@x,\@y,17);

     defined($errors) and pgerry($nlines, \@x, \@ylower, \@yupper, $term);

# End of dataset loop
   }

  pgsci(1);
  pglab("$xlabel","$ylabel","$title");
  pgend();
# End of device loop
}

# ======================================================================

sub minmax
{
    my (@numbers);

    @numbers = @_;

    my ($min, $max);

    $min = $numbers[0];
    $max = $numbers[0];

    foreach my $i (@numbers)
    {
        if ($i > $max)
        {
            $max = $i;
        }
        elsif ($i < $min)
        {
            $min = $i;
        }
    }

    return ($min, $max);
}

# ======================================================================


