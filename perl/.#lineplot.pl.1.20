#!/usr/local/bin/perl -w
# ======================================================================
#+
$usage = "\n
NAME
        lineplot.pl

PURPOSE
        Plot two or three column plain text files as connected points
        with error bars.

USAGE
        lineplot.pl [flags] [options] \$project.txt \$other.txt ...

FLAGS
        -u        Print this message
        -l        Connect points with a line
        -p        Plot data points
        -e        Plot error bars
        -logx     Logarithmic x axis
        -logy     Logarithmic y axis
        -t        Time (hh mm ss) x axis
        -q        Plot quietly (no X display)

INPUTS
        \$project.txt        3 column text file (x, y, error)

OPTIONAL INPUTS
        -v        i         Verbosity (0, 1 or 2)
        -aspect   f         aspect ratio of plot
        -xmin     f         Window xmin
        -xmax     f         xmax
        -ymin     f         ymin
        -ymax     f         ymax
        -color    i         PGPLOT color index
        -lw       i         PGPLOT line width
        -ls       i         PGPLOT line style
        -ch       f         PGPLOT character height
        -ps       i         PGPLOT point style
        -m        f         Straight line reference gradient
        -c        f         Straight line reference intercept
        -x0       f         Reference point x coord
        -y0       f         Reference point y coord
        -legend   s         File with legend text (one line per file!)
        -style    s         File with style parameters (one line per file!)
        -o        \$project Postscript output file

        \$other.txt         Additional text file

OUTPUTS
        \$project.ps        Postscript plot

COMMENTS
  - PGPLOT module requires /usr/local/bin/perl at KIPAC
  - style file lines should be of the form:
      ci lw ls       for -l option (lines)
      ci lw ls ch ps for -p -l option (lines and points)
      ci ch ps       for -p option (points)
    where
      ci = PGPLOT colour index (1=black,2=red,3=green,4=blue, etc)   
      lw = PGPLOT line width    
      ls = PGPLOT line style (1=solid,2=dashed,3=dot-dashed,4=dotted)    
      ch = PGPLOT character height    
      ps = PGPLOT character style (1=small points,17=filled circles, etc)   

EXAMPLES

BUGS

REVISION HISTORY:
  2005-08-02  Started Marshall and Cevallos (KIPAC)
  2008-07-18  Legends and styles in files Marshall (UCSB)

\n";

#-
# ======================================================================

$sdir = $ENV{'SCRIPTUTILS_DIR'};
require($sdir."/perl/minmax.pl");

use PGPLOT;

# Parse options:

use Getopt::Long;
GetOptions("o=s", \$plotfile,
           "v=i", \$verb,
           "aspect=f", \$aspect,
           "xmin=f", \$xmin,
           "xmax=f", \$xmax,
           "ymin=f", \$ymin,
           "ymax=f", \$ymax,
           "color=i", \$color,
           "ls=i", \$linestyle,
           "ch=f", \$ch,
           "lw=i", \$lw,
           "ps=i", \$pointstyle,
           "m=f", \$m,
           "c=f", \$c,
           "x0=f", \$x0,
           "y0=f", \$y0,
           "e", \$errors,
           "p", \$points,
           "l", \$line,
           "logx", \$logx,
           "logy", \$logy,
           "t", \$time,
           "q", \$quiet,
           "xlabel=s", \$xlabel,
           "ylabel=s", \$ylabel,
           "title=s", \$title,
           "legend=s", \$legendfile,
           "style=s", \$stylefile,
           "u", \$help
           );

(defined($help)) and die "$usage\n";

(defined($verb)) or ($verb = 0);

# If -e is selected, term is the relative length of error bar terminals
(defined($errors)) and ($points = 1);
$term = 0.3;

# Aspect ratio of plot:
(defined($aspect)) or $aspect = 0.707;

# General character height:
$ch0 = 1.5;
(defined($ch)) or $ch = 1.5;

# General line width:
$lw0 = 2;

# Plot line width:
(defined($lw)) or $lw = 3;

# General line style:
$ls0 = 1;
$ls = 1;
(defined($linestyle)) and $ls = $linestyle;

# General line colour:
(defined($color)) and $ci = $color;
(defined($color)) or $ci = 1;

# General point style:
$ps = 17;
(defined($pointstyle)) and $ps = $pointstyle;

# Plot labelling:
(defined($xlabel)) or $xlabel = " ";
(defined($ylabel)) or $ylabel = " ";
(defined($title)) or $title = " ";

# # Reference straight line:
# $ref = 0;
# (defined($m)) and $ref = 1;
# (defined($c)) or $c = 0.0;
# if ($ref) {
#   $x1 = $xmin;
#   $y1 = $m * $x1 + $c;
#   $x2 = $xmax;
#   $y2 = $m * $x2 + $c;
#   (defined($logx)) and $x1 = log($x1)/log(10);
#   (defined($logx)) and $x2 = log($x2)/log(10);
#   (defined($logy)) and $y1 = log($y1)/log(10);
#   (defined($logy)) and $y2 = log($y2)/log(10);
#  }

# Plot limits - need to take logs if required:
(defined($xmin) and defined($logx)) and $xmin = log($xmin)/log(10);
(defined($xmax) and defined($logx)) and $xmax = log($xmax)/log(10);
(defined($ymin) and defined($logy)) and $ymin = log($ymin)/log(10);
(defined($ymax) and defined($logy)) and $ymax = log($ymax)/log(10);

# Grab files from command line, and set up other file names:
$k = 0;
while (defined($infile = shift)){
  open (IN, $infile) or die "$infile: $!";
  close (IN);
  $file[$k] = $infile;
  $k++;
}
$nfiles = $k;

(defined($plotfile)) or ($sensible = 1);

(defined($sensible) and $nfiles > 1) and die "Must specify postscript filename with more than one file.";

if (defined($sensible)) {
   $plotfile = $file[0];
   $plotfile =~ s/(.*)\..*/$1/;
   $plotfile = $plotfile.".ps";
}

$legend = 0;
(defined($legendfile)) and ($legend = 1);
$style = 0;
(defined($stylefile)) and ($style = 1);

# ----------------------------------------------------------------------
$ignorelessthanthis = -1e32;
$log10tiny = -32.0;

# Plot twice, once to screen and once to file:

for($k=0; $k<2; $k++){

  if($k == 0){
    $device = "/xs";
    defined($quiet) and $device = "/null";
  }
  else{
     $device = "$plotfile/vcps";
  }
  ($verb == 2) and print "Device set to $device\n";

  pgbeg(0,$device,1,1);
  pgpap(0.0,$aspect);
  pgsvp(0.15,0.9,0.15,0.9);
  pgsch($ch0);
  pgslw($lw0);

# If legend file supplied, open here:
  if ($legend){
    open (LEGEND, $legendfile);
  }
# If style file supplied, open here:
  if ($style){
    open (STYLE, $stylefile);
  }

# Open up file, read in 2 or 3 columns, and add to plot:

  for($j=0; $j<$nfiles; $j++){

    (($verb > 0) and $k == 0) and print "Reading data from $file[$j]\n";
    open (IN, $file[$j]);

    (($verb > 1) and $k == 0) and print "Contents are: \n";
    $i = 0;
    while (<IN>){

      next if (/^\#/ or /^$/);
      chomp;
      @cols = split;

      $x[$i] = $cols[0];
      $y[$i] = $cols[1];
      $stdev[$i] = $cols[2];

      if (($verb > 1) and $k == 0){
        if (defined($errors)){
          print "$x[$i] $y[$i] $stdev[$i] \n";
        } else {
          print "$x[$i] $y[$i] \n";
        }
      }

      if(defined($errors)){
        $ylower[$i] = $y[$i] - $stdev[$i];
        $yupper[$i] = $y[$i] + $stdev[$i];
      }

# Take logs!
      if (defined($logx)) {
        if ($x[$i] == 0.0){
          $x[$i] = $log10tiny;
        } else {
          $x[$i] = log($x[$i])/log(10);
        }
      }
      if (defined($logy)) {
        if ($y[$i] == 0.0){
          $y[$i] = $log10tiny;
        } else {
          $y[$i] = log($y[$i])/log(10);
        }
        if(defined($errors)){
          if ($y[$i] == 0.0){
            $ylower[$i] = $log10tiny;
          } else {
            $ylower[$i] = log($ylower[$i])/log(10);
          }
          if ($yupper[$i] == 0.0){
            $yupper[$i] = $log10tiny;
          } else {
            $yupper[$i] = log($yupper[$i])/log(10);
          }
       }
      }

      $i++;
     }
     $nlines = $i;
     (($verb > 0) and $k == 0) and print "$nlines lines read\n";

     close (IN);

     if($j == 0 and $k ==0){
        @temp = minmax($ignorelessthanthis,@x);
        (defined($xmin)) or $xmin = $temp[0];
        (defined($xmax)) or $xmax = $temp[1];
        @temp = minmax($ignorelessthanthis,@y);
        (defined($ymin)) or $ymin = $temp[0];
        (defined($ymax)) or $ymax = $temp[1];
        ($verb>0) and print "Window limits set to $xmin $xmax $ymin $ymax\n";
#         (defined($logx)) and $xmin = log($xmin)/log(10);
#         (defined($logx)) and $xmax = log($xmax)/log(10);
#         (defined($logy)) and $ymin = log($ymin)/log(10);
#         (defined($logy)) and $ymax = log($ymax)/log(10);
     }
     if($j == 0){
       pgsci(1);
       pgwindow($xmin,$xmax,$ymin,$ymax);
       if (defined($time)){
         printf STDERR "calling pgtbox\n";
         pgtbox("BCNSTHYFO",0.0,0,"BCNST",0.0,0);
       } else {
         if (defined($logx) and defined($logy)){
  #          pgenv($xmin,$xmax,$ymin,$ymax,0,30);
           pgbox("BCNSTL",0.0,0,"BCNSTL",0.0,0);
         } elsif (defined($logx) and ! defined($logy)){
  #          pgenv($xmin,$xmax,$ymin,$ymax,0,10);
           pgbox("BCNSTL",0.0,0,"BCNST",0.0,0);
         } elsif (! defined($logx) and defined($logy)){
  #          pgenv($xmin,$xmax,$ymin,$ymax,0,20);
           pgbox("BCNST",0.0,0,"BCNSTL",0.0,0);
         } else {
  #          pgenv($xmin,$xmax,$ymin,$ymax,0,1);
           pgbox("BCNST",0.0,0,"BCNST",0.0,0);
         }
       }
       pglab("$xlabel","$ylabel","$title");
       if ($legend){
         if ($k == 0){
           printf STDERR "  Use cursor to select legend position...\n";
           $char = "x";
           $lx0 = 0.5*($xmin+$xmax);
           $ly0 = 0.5*($ymin+$ymax);
           pgcurs($lx0,$ly0,$char);
           pgqcs(4,$dx,$dy)
         }
         $lx = $lx0;
         $ly = $ly0;
       }
     } else {
        if ($legend){
          $ly = $ly - 1.3*$dy;
        }
     }

# Set up plotting style for this dataset:
     
     if ($style){

#    Read in parameters from style file:
       $_ = readline STYLE;
       chomp;
       @pars = split;
       $ci = shift(@pars);
       if (defined($line)) {
         $lw = shift(@pars);
         $ls = shift(@pars);
       }
       if (defined($points)) {
         $ch = shift(@pars);
         $ps = shift(@pars);
       }

     }else{
     
#    Set colour index:
       # white = 1, red = 2, green =3, blue =4 etc etc
       (defined($color)) or $ci = $j + 1;
#        # String paper scheme (green, red, blue, ...)!
#        @colourindex = (3,2,4,1,5,6,7,8,9,10,11,12);
#        (defined($color)) or $ci = $colourindex[$j];
#        # Nice scheme (grey, red, blue...)!
#        @colourindex = (14,2,11,3);
#        (defined($color)) or $ci = $colourindex[$j];
#        # Filters and spectra (grey, grey, red, blue...)!
#        @colourindex = (14,14,8,11);
#        (defined($color)) or $ci = $colourindex[$j];

#    Set line style:
       # String paper scheme (green, red, blue, ...)!
       @linestyleindex = (1,2,4,3);
#        # Nice scheme!
#        @linestyleindex = (4,2,1,3);
#        # Filters and spectra (grey, grey, red, blue...)!
#        @linestyleindex = (4,4,1,1);
       (defined($linestyle)) or $ls = $linestyleindex[$j];

#    Character style, size, line width are already set from command line.

     }

     ($verb > 0) and print "Dataset $j: colour index set to $ci\n";
     pgsci($ci);

# Draw line:
     if (defined($line)) {
       ($verb > 0) and print "Dataset $j: line style set to $ls\n";
       pgsls($ls);
       ($verb > 0) and print "Dataset $j: line width set to $lw\n";
       pgslw($lw);
       pgline($nlines, \@x, \@y);
       pgslw($lw0);
       pgsls($ls0);
     }

# Plot points:
     if (defined($points)) {
       ($verb > 0) and print "Dataset $j: character height set to $ch\n";
       pgsch($ch);
       ($verb > 0) and print "Dataset $j: character style set to $ps\n";
       pgpt($nlines,\@x,\@y,-$ps);
       pgsch($ch0);
     }

# Plot error bars:
     defined($errors) and pgerry($nlines, \@x, \@ylower, \@yupper, $term);

# Add legend if required:

     if ($legend){
       $text = readline LEGEND;
       chomp($text);
       $x1 = $lx;
       $y1 = $ly + 0.3*$dy;
       pgmove($x1,$y1);
       $x2 = $lx + 3*$dx;
       $y2 = $y1;
       pgslw($lw);
       pgsls($ls);
       pgdraw($x2,$y2);
       pgsci(1);
       pgslw($lw0);
       pgsls($ls0);
       pgsch($ch0);
       $x3 = $lx + 4*$dx;
       $y3 = $ly;
       pgtext($x3,$y3,$text);
     }

# End of dataset loop
  }
  
# Close legend and style files:  
  ($legend) and close (LEGEND);
  ($style) and close (STYLE);


# Draw reference straight line (dotted):

  $ref = 0;
  (defined($m)) and $ref = 1;
  (defined($c)) or $c = 0.0;
  if ($ref) {
    $x1 = $xmin;
    (defined($logx)) and $x1 = exp($x1*log(10));
    $x2 = $xmax;
    (defined($logx)) and $x2 = exp($x2*log(10));
    $y1 = $m * $x1 + $c;
    $y2 = $m * $x2 + $c;
    (defined($logx)) and $x1 = log($x1)/log(10);
    (defined($logx)) and $x2 = log($x2)/log(10);
    (defined($logy)) and $y1 = log($y1)/log(10);
    (defined($logy)) and $y2 = log($y2)/log(10);
  }

# Draw reference point (star):

  $refpt = 0;
  (defined($x0)) and $refpt = 1;
  (defined($y0)) or $y0 = $x0;
  if ($refpt) {
    (defined($logx)) and $x0 = exp($x0*log(10));
    (defined($logy)) and $y0 = exp($y0*log(10));
  }

  pgsci(1);
  if ($refpt) {
    pgsls(2.0);
    pgpt1($x0,$y0,12);
    pgsls($ch0);
  }

  pglab("$xlabel","$ylabel","$title");
  pgend();
# End of device loop
}

# ======================================================================
